# 検証レポート: Symbolic Engine とルールマッチング

## 概要
本レポートは、ユーザーリクエストで提供された定積分計算ステップに焦点を当て、Symbolic Engine の動作に関する調査結果をまとめたものです。

## 調査結果

### 1. Symbolic Engine の等価性チェック (`is_equiv`)
- **問題点**: `sympy` が存在しない環境（フォールバックモード）において、サポートされていない関数（`integrate` など）が原因で数値サンプリングが失敗した場合、`SymbolicEngine` が等価でない式（例: `8` と `x^2 + 1`）に対して誤って `True` を返していました。
- **修正**: フォールバック評価器を更新し、すべてのサンプルで評価が失敗した場合は、等価と見なすのではなく、保守的に `False` を返すように変更しました。
- **検証**:
    - **修正前**: `is_equiv("3*integrate(x**2, (x,0,2))", "3*((x**2+1)/3)")` -> `True` (不正解)
    - **修正後**: `is_equiv("3*integrate(x**2, (x,0,2))", "3*((x**2+1)/3)")` -> `False` (正解)
- **影響**: これにより、フォールバック環境であっても、誤った中間ステップ（原始関数における積分の境界値の適用忘れなど）が正しく「間違い（Mistake）」としてフラグ付けされるようになります。

### 2. ルールマッチング (`match_structure`)
- **観察**: ユーザーから提供されたログでは、ステップ 5 (`[x^3]_0^2`) が `ok` と判定され、`rule_id: ARITH-CALC-MUL` が付与されていました。
- **分析**:
    - `[x^3]_0^2` は内部処理用に `Subs(x**3, x, 2) - Subs(x**3, x, 0)` に正規化されます。
    - `ARITH-CALC-MUL` ルール（パターン `a * b`）は、本来この構造にはマッチしません。
    - **仮説**: ユーザーの環境では、`sympy` の単一化（unification）の特定の挙動、あるいは汎用的な計算ルールがトリガーされるようなルール優先順位の設定ミスにより、`ARITH-CALC-MUL` がマッチしている可能性があります。ただし、ステップ 5 は `8` に評価され（問題の答えと同じ）、ルールマッチの結果に関わらず正しく `Valid` と判定されています。
- **フォールバック時の挙動**: `sympy` がないフォールバックモードでは、`match_structure` は `None` を返すため、ルールはマッチしません。これは軽量なフォールバックエンジンの想定された動作です。

### 3. レンダリングマッチ
- **観察**: ユーザーログの `rendered` フィールドは、入力式を正しく反映しています。
- **検証**: パーサーは `[x^3]_0^2` という表記を正しく処理し、ユーザーの意図を保持しつつ、内部処理用に `Subs` 形式へ正規化しています。

## 結論
- **Symbolic Engine** は、提供された計算ステップにおける間違い（ステップ 2, 3, 4）を正しく識別できるように設計されています。
- ユーザー環境における **ルールマッチング** システムは稼働しているようですが、ステップ 5 に対して特定されたルール（`ARITH-CALC-MUL`）は、減算/代入操作としては意味的に不正確と思われるため、完全な `sympy` 環境でのさらなる調査が必要です。
- **レンダリング** ロジックは期待通りに機能しています。

## 推奨事項
- 完全なルールマッチングと堅牢な等価性チェックを有効にするため、本番環境には `sympy` をインストールすることを推奨します。
- `core/symbolic_engine.py` に適用された修正により、`sympy` が利用できない環境での安定性が向上しました。
